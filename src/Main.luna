import Std.Base
import Std.Foreign
import Std.Foreign.C.Value
import Std.Time

import Dataframes.Internal.Utils

# type-erased class that wraps an array builder for some type (identified by string)
class ArrayBuilderWrapper:
    ptr :: ManagedPtr None
    typename :: Text

    def cCall nameSuffix ret args: 
        callHandlingError ("builder" + self.typename + nameSuffix) ret ([self.ptr.toCArg] + args)

    # value should be a C-compatible value (type-erased base doesn't know what is the argument size)
    def append value:
        self.cCall "AppendValue" None [value.toCArg]

    def appendNull:
        self.cCall "AppendNull" None []

    # resize if needed
    def reserve count:
        self.cCall "Reserve" None [CInt64.fromInt count . toCArg]

    def resize count:
        self.cCall "Resize" None [CInt64.fromInt count . toCArg]

    # 
    def finish:
        arrPtr = self.cCall "Finish" (Pointer None) []
        managedPtr = ManagedPointer None . fromPointer releaseMethod arrPtr
        ArrayWrapper managedPtr self.typename

class ArrayWrapper:
    ptr :: ManagedPointer None
    typename :: Text

    def length:
        callHelper "arrayLength" CInt64 [self.ptr.toCArg] . toInt

    def value index retType:
        callHandlingError ("array" + self.typename + "ValueAt") retType [self.ptr.toCArg, CInt64.fromInt index . toCArg]


def createBuilderWrapper type:
    result = callHandlingError ("builder" + type + "New") (Pointer None) []
    ptr = ManagedPointer None . fromPointer releaseMethod result
    ArrayBuilderWrapper ptr type

class Int32TypeHelper:
    def withValueAsC value f:
        f (CInt32.fromInt value)
    def typename: "Int32"
    def ctype: CInt32
    def fromC val:
        CInt64.toInt val
class Int64TypeHelper:
    def withValueAsC value f:
        f (CInt64.fromInt value)
    def typename: "Int64"
    def ctype: CInt64
    def fromC val:
        val.toInt

class AArray a:
    typeTag :: a
    ptr :: ArrayWrapper

    def length: 
        self.ptr.length
    def valueAt index:
        cval = self.ptr.value index self.typeTag.ctype
        self.typeTag.fromC cval
    def toList:
        0.upto (self.length - 1) . each (self.valueAt _)
    def toText:
        self.toList.toText
    
    # TODO: could be faster: deep copy buffer and overwrite with new values
    # TODO: handle null presence
    def map f:
        builder = createBuilder self.typeTag
        self.toList.each val:
            builder.append (f val)
        builder.finish

class ArrayBuilder a:
    typeTag :: a
    bw :: ArrayBuilderWrapper

    def append value:
        self.typeTag.withValueAsC value self.bw.append
    def appendMany values:
        values . each self.append
    def finish:
        ptr = self.bw.finish
        AArray (self.typeTag) ptr

def createBuilder typeTag:
    bw = createBuilderWrapper typeTag.typename
    ArrayBuilder typeTag bw

def main:
    builder = createBuilder Int64TypeHelper
    builder.append 7
    benchmark "append x200" (builder.appendMany (1 . upto 20))
    arrw = builder.finish
    print "after finish"
    print arrw.length
    print (arrw.valueAt 10)
    print arrw
    arrwInc = arrw.map (_ + 1)
    print arrwInc
    print "Done"