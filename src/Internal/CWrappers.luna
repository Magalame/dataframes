import Std.Foreign
import Std.Foreign.C.Value

import Dataframes.Internal.Utils

class DataTypeWrapper:
    ptr :: ManagedPointer None
    
    def callSelf nameSuffix ret args:
        callHandlingError ("dataType" + nameSuffix) ret ([self.ptr.toCArg] + args)
    def name:
        self.callSelf "Name" CString [] . toText
    def toText:
        self.callSelf "ToString" CString [] . toText
    def typeId:
        self.callSelf "Id" CInt8 [] . toInt
    # warning: only fixed-width types support this operation
    # TODO: somehow enforce this on the type level 
    def bitWidth:
        self.callSelf "FixedWidthTypeBitWidth" CInt32 [] . toInt

# type-erased class that wraps an array builder for some type (identified by string)
class ArrayBuilderWrapper:
    ptr :: ManagedPtr None
    typename :: Text

    def toCArg: 
        self.ptr.toCArg
    def selfCall fullNameSuffix ret args:
        callHandlingError ("builder" + fullNameSuffix) ret ([self.ptr.toCArg] + args)
    def typeCall nameSuffix ret args:
        self.selfCall (self.typename + nameSuffix) ret args

    # value should be a C-compatible value (type-erased base doesn't know what is the argument size)
    def append value:
        self.typeCall "AppendValue" None [value.toCArg]

    # NOTE: should not be called if builded array is expected to be null free 
    # (rule should be enforced by owning code)
    # TODO: in future enforce by type system
    def appendNull:
        self.typeCall "AppendNull" None []

    # resize if needed
    def reserve count:
        self.typeCall "Reserve" None [CInt64.fromInt count . toCArg]

    def resize count:
        self.typeCall "Resize" None [CInt64.fromInt count . toCArg]

    def capacity:
        callHelper "builderCapacity" CInt64 [self.toCArg] . toInt
    def length:
        callHelper "builderLength" CInt64 [self.toCArg] . toInt

    # 
    def finish:
        ptr = self.typeCall "Finish" (Pointer None) []
        wrapReleasableResouce ArrayWrapper ptr

    def type:
        ptr = self.selfCall "ObtainType" (Pointer None) []
        wrapReleasableResouce DataTypeWrapper ptr

class ArrayWrapper:
    ptr :: ManagedPointer None

    def length:
        callHelper "arrayLength" CInt64 [self.ptr.toCArg] . toInt

    def value index retType typename:
        callHandlingError ("array" + typename + "ValueAt") retType [self.ptr.toCArg, CInt64.fromInt index . toCArg]

    def data:
        ptr = callHandlingError ("arrayData") (Pointer None) [self.ptr.toCArg]
        wrapReleasableResouce ArrayDataWrapper ptr

    def nullAt index:
        ret = callHandlingError "arrayIsNullAt" CInt8 [self.ptr.toCArg, CInt64.fromInt index . toCArg] . toInt
        ret == 1

    def slice fromIndex length:
        ptr = callHandlingError "arraySlice" (Pointer None) [self.ptr.toCArg, CInt64.fromInt fromIndex . toCArg, CInt64.fromInt length . toCArg]
        wrapReleasableResouce ArrayWrapper ptr

class BufferWrapper:
    ptr :: ManagedPointer None

    def copyNFrom copyFromIndex copyLength:
        ptr = callHandlingError "bufferCopy" (Pointer None) [self.ptr.toCArg, CInt64.fromInt copyFromIndex . toCArg, CInt64.fromInt copyLength . toCArg]
        wrapReleasableResouce BufferWrapper ptr
    def slice sliceFromIndex sliceLength:
        ptr = callHandlingError "bufferSlice" (Pointer None) [self.ptr.toCArg, CInt64.fromInt sliceFromIndex . toCArg, CInt64.fromInt sliceLength . toCArg]
        wrapReleasableResouce BufferWrapper ptr
    def size:
        callHandlingError "bufferSize" CInt64 [self.ptr.toCArg] . toInt
    def data:
        callHandlingError "bufferData" (Pointer None) [self.ptr.toCArg]

class ArrayDataWrapper:
    ptr :: ManagedPointer None

    def nullCount:
        callHelper "arrayDataNullCount" CInt64 [self.ptr.toCArg] . toInt
    def length:
        callHelper "arrayDataLength" CInt64 [self.ptr.toCArg] . toInt
    def offset:
        callHelper "arrayDataOffset" CInt64 [self.ptr.toCArg] . toInt
    def bufferCount:
        callHelper "arrayDataBufferCount" CInt64 [self.ptr.toCArg] . toInt
    def bufferAt index:
        ptr = callHandlingError "arrayDataBufferAt" (Pointer None) [self.ptr.toCArg, CInt64.fromInt index . toCArg]
        wrapReleasableResouce BufferWrapper ptr
    def type:
        ptr = callHandlingError "arrayDataType" (Pointer None) [self.ptr.toCArg]
        wrapReleasableResouce DataTypeWrapper ptr

def createBuilderWrapper type:
    ptr = callHandlingError ("builder" + type + "New") (Pointer None) []
    wrapReleasableResouce ArrayBuilderWrapper ptr type

class ChunkedArrayWrapper:
    ptr :: ManagedPointer None
    
    def nullCount:
        callHelper "chunkedArrayNullCount" CInt64 [self.ptr.toCArg] . toInt
    def length:
        callHelper "chunkedArrayLength" CInt64 [self.ptr.toCArg] . toInt
    def chunkCount:
        callHelper "chunkedArrayChunkCount" CInt64 [self.ptr.toCArg] . toInt
    def chunkAt index:
        ptr = callHandlingError "chunkedArrayChunkAt" (Pointer None) [self.ptr.toCArg, CInt32.fromInt index . toCArg]
        wrapReleasableResouce ArrayWrapper ptr
    def type:
        ptr = callHandlingError "chunkedArrayDataType" (Pointer None) [self.ptr.toCArg]
        wrapReleasableResouce DataTypeWrapper ptr

def createChunkedArrayWrapperSingleton arrayWrapper:
    ptr = callHandlingError "chunkedArrayNewSingleton" (Pointer None) [arrayWrapper.ptr.toCArg]
    wrapReleasableResouce ChunkedArrayWrapper ptr

def createChunkedArrayWrapperChunks arrayWrappers:
    withArray (Pointer None) (arrayWrappers.each .ptr.ptr) arrayC:
        ptr = callHandlingError "chunkedArrayNewChunks" (Pointer None) [arrayC.ptr.toCArg, CInt32.fromInt arrayC.size . toCArg]
        wrapReleasableResouce ChunkedArrayWrapper ptr

