import Std.Test

import Dataframes.Array
import Dataframes.Column
import Dataframes.Types
import Dataframes.IO

def executeTest msg action:
    result = runError action
    case result of
        Left e: print ("[FAILURE] " + msg + ": " + e)
        Right v: print ("[SUCCESS] " + msg + ": " + v.toText)
    None

def require pred msg:
    if pred then msg else throw msg
def assert msg act:
    executeTest msg (require act "predicate")
def assertEqual msg a b:
    executeTest msg (require (a == b) (a.toText + " == " + b.toText))
def assertNE msg a b:
    executeTest msg (require (a == b).not (a.toText + " != " + b.toText))
def assertGE msg a b:
    executeTest msg (require (a >= b) (a.toText + " >= " + b.toText))
def assertNoThrow msg action:
    result = runError action
    print case result of
        Left e: "[FAILUJE] " + msg + ": threw " + e
        Right v: "[SUCCESS] " + msg + ": didn't throw: " + v.toText
def assertThrow msg action:
    result = runError action
    print case result of
        Left e: "[SUCCESS] " + msg + ": threw " + e
        Right v: "[FAILURE] " + msg + ": no throw: " + v.toText

class TestArrayBuilder:
    def testDoubleBuilder:
        print "=== Testing for Double ==="
        builder = createBuilder DoubleType
        type = builder.type
        assertEqual "initial capacity" builder.capacity 0
        assertEqual "initial length" builder.length 0
        assertEqual "type width" type.bitWidth 64
        assertEqual "type name" type.name "double"
        assertEqual "type as text" type.toText "double"
        builder.append 7.0
        builder.appendMany (1 . upto 3 . each .toReal)
        assertGE "builder.capacity" builder.capacity 4
        assertEqual "builder.length" builder.length 4
        builtArray = builder.finish
        assertThrow ("invalid index -1 throws") (builtArray.valueAt -1)
        assertThrow ("invalid index 6 throws") (builtArray.valueAt 6)
        assertEqual "built single elem array" builtArray.toList [7.0, 1.0, 2.0, 3.0]
    def testInt64Builder:
        print "=== Testing for Int ==="
        builder = createBuilder Int64Type
        type = builder.type
        assertEqual "initial capacity" builder.capacity 0
        assertEqual "initial length" builder.length 0
        assertEqual "type width" type.bitWidth 64
        assertEqual "type name" type.name "int64"
        assertEqual "type as text" type.toText "int64"
        builder.append 7
        builder.appendMany (1 . upto 5)
        assertGE "builder.capacity" builder.capacity 6
        assertEqual "builder.length" builder.length 6
        builtArray = builder.finish
        assertThrow ("invalid index -1 throws") (builtArray.valueAt -1)
        assertThrow ("invalid index 6 throws") (builtArray.valueAt 6)
        assertEqual "built single elem array" builtArray.toList [7, 1, 2, 3, 4, 5]
        assertEqual "map to the same type" (builtArray.mapSame (+10) . toList) [17, 11, 12, 13, 14, 15]
        def someFunction num: if num > 3 then Nothing else Just ("foo " + num.toText)
        assertEqual "map that changes type" (builtArray.map MaybeStringType someFunction . toList) [Nothing, Just "foo 1", Just "foo 2", Just "foo 3", Nothing, Nothing]

    def testMaybeInt64Builder:
        print "=== Testing for (Maybe Int) ==="
        builder = createBuilder MaybeInt64Type
        type = builder.type
        assertEqual "initial capacity" builder.capacity 0
        assertEqual "initial length" builder.length 0
        assertEqual "type width" type.bitWidth 64
        assertEqual "type name" type.name "int64"
        assertEqual "type as text" type.toText "int64"
        builder.append (Just 7)
        builder.append (Nothing)
        builder.appendMany (1 . upto 3 . each (Just))
        assertGE "builder.capacity" builder.capacity 5
        assertEqual "builder.length" builder.length 5
        builtArray = builder.finish
        assert "not null at 0" (builtArray.nullAt 0 . not)
        assert "null at 1" (builtArray.nullAt 1)
        assertThrow "null at -1 throws" (builtArray.nullAt -1)
        assertEqual "value at 0" (builtArray.valueAt 0) (Just 7)
        assertEqual "value at 1" (builtArray.valueAt 1) Nothing
        assertEqual "built single elem array" builtArray.toList [Just 7, Nothing, Just 1, Just 2, Just 3]
        assertEqual "map to the same type" (builtArray.mapSame (_.map (+10)) . toList) [Just 17, Nothing, Just 11, Just 12, Just 13]

    # TODO: properly handle `assertEqual "type width" type.bitWidth 64`
    def testMaybeStringBuilder:
        print "=== Testing for (Maybe Text) ==="
        builder = createBuilder MaybeStringType
        type = builder.type
        assertEqual "initial capacity" builder.capacity 0
        assertEqual "initial length" builder.length 0
        assertThrow "type width throws (not fixed width type)" type.bitWidth
        assertEqual "type name" type.name "utf8"
        assertEqual "type as text" type.toText "string"
        builder.append (Just "first")
        builder.append (Nothing)
        nums = (1 . upto 3) . each (Just _.toText)
        print ("nums: " + nums.toText)
        builder.appendMany (nums)
        assertGE "builder.capacity" builder.capacity 5
        assertEqual "builder.length" builder.length 5
        builtArray = builder.finish
        assert "not null at 0" (builtArray.nullAt 0 . not)
        assert "null at 1" (builtArray.nullAt 1)
        assertEqual "value at 0" (builtArray.valueAt 0) (Just "first")
        assertEqual "value at 1" (builtArray.valueAt 1) Nothing
        assertEqual "built single elem array" builtArray.toList [Just "first", Nothing, Just "1", Just "2", Just "3"]
        print "================================="
        print (builtArray.mapSame elem:
            case elem of 
                Just val: Just (val + "-suffix")
                Nothing: Nothing)

    def testRoundTrip msg typeTag list:
        arr = listToArray typeTag list
        assertEqual "array and list length same" arr.length list.length
        assertEqual msg (arr . toList) list

    def testListArrayRoundTrip:
        self.testRoundTrip "Double64 round trip" DoubleType [10.25, -5.825,  5000000000.0]
        self.testRoundTrip "Maybe Double64 round trip" MaybeDoubleType [Just 10.25, Just -5.825, Just 5000000000.0, Nothing]
        self.testRoundTrip "Int32 round trip" Int32Type [10, -5,  1000000000]
        self.testRoundTrip "Maybe Int32 round trip"MaybeInt32Type [Just 10, Just -5, Just 1000000000, Nothing]
        self.testRoundTrip "Int64 round trip" Int64Type [10, -5,  5000000000]
        self.testRoundTrip "Maybe Int64 round trip"MaybeInt64Type [Just 10, Just -5, Just 5000000000, Nothing]
        self.testRoundTrip "Text round trip" StringType ["ten", "-5", "legion"]
        self.testRoundTrip "Maybe Text round trip" MaybeStringType [Just "ten", Just "-5", Just "legion", Nothing]

    def testSlicing:
        arr = listToArray Int32Type [1, 2, 3, 4, 5]
        arr2 = arr.slice 1 3
        assertEqual "slice result" arr2.toList [2, 3, 4]
        buf1Ptr = arr.data.bufferAt 1 . data
        buf2Ptr = arr2.data.bufferAt 1 . data
        assert "ptr equal" (buf1Ptr.ptr == buf2Ptr.ptr)
        assertEqual "sliced data has proper offset" arr2.data.offset (arr.data.offset+1)

    def testChunkedArray:
        arr = listToArray Int32Type [1, 2, 3, 4, 5]
        charr = createChunkedArrayFromChunk arr
        assertEqual "chunked array type" charr.type.name "int32"
        assertEqual "single chunk" charr.chunkCount 1
        assertEqual "length" charr.length 5

        arr2 = listToArray Int32Type [10, 20, 30]
        charr2 = createChunkedArrayFromChunks [arr, arr2]
        assertEqual "chunked array type" charr2.type.name "int32"
        assertEqual "single chunk" charr2.chunkCount 2
        assertEqual "length" charr2.length 8
        assertEqual "null count" charr2.nullCount 0
        assertEqual "second chunk" (charr2.chunkAt 1 . toList) [10, 20, 30]
        assertEqual "as list" charr2.toList [1, 2, 3, 4, 5, 10, 20, 30]

    def testDatatype:
        typeInt32 = createDatatype Int32Type
        assertEqual "name" typeInt32.name "int32"
        assertEqual "bitWidth" typeInt32.bitWidth 32

        typeInt64 = createDatatype Int64Type
        assertEqual "name" typeInt64.name "int64"
        assertEqual "bitWidth" typeInt64.bitWidth 64
        
        typeDouble = createDatatype DoubleType
        assertEqual "name" typeDouble.name "double"
        assertEqual "bitWidth" typeDouble.bitWidth 64
        
        typeString = createDatatype StringType
        assertEqual "name" typeString.name "utf8"
        assertThrow "bitWidth" typeString.bitWidth

    def testField:
        fieldInt64 = createField "x" Int64Type
        assertEqual "name" fieldInt64.name "x"
        assertEqual "type.name" fieldInt64.type.name "int64"
        assertEqual "nullable" fieldInt64.nullable False

        fieldMaybeString = createField "handle_name" MaybeStringType
        assertEqual "name" fieldMaybeString.name "handle_name"
        assertEqual "type.name" fieldMaybeString.type.name "utf8"
        assertEqual "nullable" fieldMaybeString.nullable True

    def testColumn:
        col = Column.fromList "good numbers" Int64Type [1,20,333]
        assertEqual "length" col.length 3
        assertEqual "name" col.name "good numbers"
        isIntCol = case col of
            ColumnInt _: True
            _: False
        assert "matched ColumnInt" isIntCol
        intCol = case col of
            ColumnInt tc: tc
        assertEqual "intCol.toList" intCol.toList [1,20,333]
        assertEqual "slice 1 1" (col.slice 1 1).toList [20]
        assertEqual "slice 1 2" (col.slice 1 2).toList [20, 333]

        colMappedReal = col.map Int64Type DoubleType "reals" (num: num.toReal + 1.5)
        print "========================================"
        assertEqual "real name" colMappedReal.name "reals"
        assertEqual "real contents" colMappedReal.toList [2.5, 21.5, 334.5]
        colMappedText = colMappedReal.map DoubleType StringType "good strings" (num: "good " + num.toText)
        assertEqual "text name" colMappedText.name "good strings"
        assertEqual "text contents" colMappedText.toList ["good 2.5", "good 21.5", "good 334.5"]
        colMappedMaybeText = colMappedText.map StringType MaybeStringType "maybe strings" Just
        assertEqual "maybe text contents" colMappedMaybeText.toList [Just "good 2.5", Just "good 21.5", Just "good 334.5"]
        colMappedMaybeInt = colMappedMaybeText.map MaybeStringType MaybeInt64Type "maybe strings" (maybeText: maybeText.map .length)
        assertEqual "maybe int contents" colMappedMaybeInt.toList [Just 8, Just 9, Just 10]
        colMappedMaybeReal = colMappedMaybeInt.map MaybeInt64Type MaybeDoubleType "maybe strings" (maybeNum: Just (maybeNum.get.toReal + 0.5))
        assertEqual "maybe real contents" colMappedMaybeReal.toList [Just 8.5, Just 9.5, Just 10.5]

    def testSchema:
        x = createField "x" Int64Type
        y = createField "y" Int64Type
        z = createField "z" MaybeInt64Type
        name = createField "name" StringType
        value = createField "value" DoubleType
        
        schema = createSchema [x, y, z, name]
        assertEqual "fieldCount" schema.fieldCount 4
        assertThrow "field negative index" (schema.fieldAt -1)
        assertEqual "field name" (schema.fieldAt 0 . name) "x"
        assertEqual "field name" (schema.fieldAt 1 . name) "y"
        assertEqual "field name" (schema.fieldAt 2 . name) "z"
        assertEqual "field name" (schema.fieldAt 3 . name) "name"
        assertThrow "field past size" (schema.fieldAt 4)
        assert "field 0 is x" (schema.fieldAt 0 . ptr . ptr . ptr == x.ptr.ptr.ptr)
        assert "field 0 is not y" (schema.fieldAt 0 . ptr . ptr . ptr == y.ptr.ptr.ptr).not
        assertGE "produces non-empty text" schema.toText.length 0
        assertEqual "find x" (schema.fieldByName "x" . get . name) "x"
        assertEqual "find w" (schema.fieldByName "w") Nothing
        assertEqual "find z index" (schema.fieldIndexByName "z") (Just 2)
        assertEqual "find v index" (schema.fieldIndexByName "v") Nothing
        assertEqual "schema fields list" schema.toList [x, y, z, name]
        assertNE "schema fields list" schema.toList [x, z, y, name]

        schema2 = schema.addField 3 value
        assertEqual "schema2 fieldCount" schema2.fieldCount 5
        assertEqual "schema2 fields list" schema2.toList [x, y, z, value, name]
        assertThrow "add field past index" (schema.addField 5 value)
        assertThrow "add field past index" (schema.addField -1 value)
        assertEqual "schema2b fields list" (schema.addField 4 value . toList) [x, y, z, name, value]
        assertEqual "schema2c fields list" (schema2.addField 4 value . toList) [x, y, z, value, value, name]

        schema3 = schema2.removeField 2
        assertEqual "schema3 fieldCount" schema3.fieldCount 4
        assertEqual "schema3 fields list" schema3.toList [x, y, value, name]
        assertThrow "remove field past index" (schema2.removeField -1)
        assertThrow "remove field past index" (schema2.removeField 5)

    def testTable:
        colX = Column.fromList "x" Int64Type [0, 10, -10, 500]
        colY = Column.fromList "y" Int64Type [1, 2, 3, 600]
        colName = Column.fromList "name" StringType ["start", "left", "right", "far away"]
        t = Table.fromColumns [colX, colY, colName]

        assertEqual "column count" t.columnCount 3
        assertEqual "row count" t.rowCount 4

        schema = t.schema
        assertEqual "schema has 3 fields" schema.fieldCount 3
        assertEqual "field 0" (schema.fieldAt 0) colX.field
        assertEqual "field 1" (schema.fieldAt 1) colY.field
        assertEqual "field 2" (schema.fieldAt 2) colName.field
        
        assertThrow "access column -1" (t.columnAt -1 . toText)
        assertThrow "access column 50" (t.columnAt 50 . toText)

        col0 = t.columnAt 0
        assertEqual "column 0 contents" col0.toList [0, 10, -10, 500]
        assertEqual "column 0 name" col0.name "x"

        assertThrow "removing column by index -1" (t.removeColumn -1)
        assertThrow "removing column by index 3" (t.removeColumn 3)
        
        t2 = t.removeColumn 2
        assertEqual "columnCount" t2.columnCount 2
        assertEqual "rowCount" t2.rowCount 4
        assertEqual "names" t2.columnNames ["x", "y"]

        assertThrow "adding column at -1" (t2.addColumn -1 colName)
        assertThrow "adding column at 3" (t2.addColumn 3 colName)
        
        t3 = t2.addColumn 1 colName
        assertEqual "names" t3.columnNames ["x", "name", "y"]
        t3b = t2.addColumn 2 colName
        assertEqual "names" t3b.columnNames ["x", "y", "name"]
        assertEqual "add-remove equivalence" t t3b 
        assertNE "order equivalence" t t3 

        col0JSON = t.columnAt 0 . toJSON
        print $ "COLUMN 0 JSON: " + col0JSON.toText
        assertNoThrow "column json is map" col0JSON.asObject
        assertEqual "object size" (col0JSON.safeAsObject.map .size) (Just 2)
        assertEqual "header" (col0JSON.lookup "header") (Just ["x"].toJSON)
        assertEqual "data" (col0JSON.lookup "data") (Just [[0], [10], [-10], [500]].toJSON)

        tableJson = t.toJSON
        assertEqual "header" (tableJson.lookup "header") (Just ["x", "y", "name"].toJSON)
 
    def testCsvParser:
        print "CSV parsing case 1"
        t1 = CSVParser . useNames ["x", "y", "z"] . setTypes [IntElement, MaybeIntElement] . readText "1,2,3"
        assertEqual "names" t1.columnNames ["x", "y", "z"]
        assertEqual "col 0 typename" (t1.columnAt 0 . field.type.name) "int64"
        assertEqual "col 0 nullable" (t1.columnAt 0 . field.nullable) False
        assertEqual "col 0 toList" (t1.columnAt 0 . toList) [1]
        assertEqual "col 1 typename" (t1.columnAt 1 . field.type.name) "int64"
        assertEqual "col 1 nullable" (t1.columnAt 1 . field.nullable) True
        assertEqual "col 1 toList" (t1.columnAt 1 . toList) [Just 2]
        assertEqual "col 2 typename" (t1.columnAt 2 . field.type.name) "utf8"
        assertEqual "col 2 nullable" (t1.columnAt 2 . field.nullable) False
        assertEqual "col 2 toList" (t1.columnAt 2 . toList) ["3"]

        print "CSV parsing case 2"
        t2 = CSVParser . useNames ["x", "y"] . setTypes [] . readText '"1,2,3"'
        assertEqual "names" t2.columnNames ["x"]
        assertEqual "col 0 toList" (t2.columnAt 0 . toList) ['1,2,3']

    def run:
        self.testCsvParser
        throw "stop"
        self.testSchema
        self.testColumn
        self.testField
        self.testDatatype
        self.testChunkedArray
        self.testSlicing
        self.testDoubleBuilder
        self.testListArrayRoundTrip
        self.testMaybeStringBuilder
        self.testInt64Builder
        self.testMaybeInt64Builder
