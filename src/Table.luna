import Dataframes.Column
import Dataframes.Schema
import Dataframes.Types
import Dataframes.Internal.CWrappers
import Dataframes.Plot.Matplotlib

import Std.Foreign.C.Value

class SortOrder:
    Ascending
    Descending

    def toCArg:
        i = case self of
            Ascending: 0
            Descending: 1
        CInt8.fromInt i

class NullPosition:
    NullsBefore
    NullsAfter

    def toCArg:
        i = case self of
            NullsBefore: 0
            NullsAfter: 1
        CInt8.fromInt i

# Note: keep in sync with C++ enum with the same name
class AggregateFunction:
    Minimum
    Maximum
    Mean
    Length
    Median
    First
    Last

    def toInt: case self of
        Minimum: 0
        Maximum: 1
        Mean: 2
        Length: 3
        Median: 4
        First: 5
        Last: 6

class Table:
    Table
    TableVal (TableWrapper)

    def ptr:
        case self of
            TableVal ptr: ptr

    def fromWrapper wrapper:
        wrapper' = wrapper
        TableVal wrapper'
    def fromSchemaAndColumns schema columns:
        self.fromWrapper $ createTableWrapper schema.ptr (columns.each .ptr)

    # Constructing `Table` from a list of `Column` values.
    # 
    # > import Dataframes.Column 
    # > import Dataframes.Types
    # > import Dataframes.Table 
    # > l1 = [1,2,3,4,5]
    # > l2 = [11,12,13,14,15]
    # > col1 = Column.fromList "col1" Int64Type l1
    # > col2 = Column.fromList "col2" Int64Type l2
    # > table = Table.fromColumns [col1 , col2]
    #
    # `columns`: List of columns to construct the `Table`.
    # `return`: `Table` value with columns from the list.
    def fromColumns columns:
        fields = columns.each .field
        ptrs = columns.each .ptr
        schema = Schema.fromFields fields
        self.fromWrapper $ createTableWrapper schema.ptr ptrs
    def fromFile path:
        self.fromWrapper $ readTableFromFile path

    def columnCount: self.ptr.columnCount
    def rowCount: self.ptr.rowCount
    def schema:
        wrapper = self.ptr.schema
        SchemaVal wrapper

    # Returns a single `Column` value from `Table` by integer index.
    # 
    # > import Dataframes.Column 
    # > import Dataframes.Types
    # > import Dataframes.Table 
    # > l1 = [1,2,3,4,5]
    # > l2 = [11,12,13,14,15]
    # > col1 = Column.fromList "col1" Int64Type l1
    # > col2 = Column.fromList "col2" Int64Type l2
    # > table = Table.fromColumns [col1 , col2]
    # > column = table.columnAt 1
    #
    # `index`: Integer column index.
    # `return`: `Column` value from the `Table` for given index.

    def columnAt index:
        columnWrapper = self.ptr.columnAt index
        Column.fromColumnWrapper columnWrapper
    
    # Insert a single `Column` value to `Table` under given index.
    # 
    # > import Dataframes.Column 
    # > import Dataframes.Types
    # > import Dataframes.Table 
    # > l1 = [1,2,3,4,5]
    # > l2 = [11,12,13,14,15]
    # > col1 = Column.fromList "col1" Int64Type l1
    # > col2 = Column.fromList "col2" Int64Type l2
    # > table = Table.fromColumns [col1 , col2]
    # > l3 = [21,22,23,24,25]
    # > col3 = Column.fromList "col3" Int64Type l3 
    # > newTable = table.addColumn 1 col3
    #
    # `index`: Integer index for newly inserted column.
    # `column`: `Column` value to insert.
    # `return`: `Table` value containing previous `table` with newly inserted column.

    def addColumn index column:
        self.fromWrapper $ self.ptr.addColumn index column.ptr
    def concat ts:
        cols = ts . each .toList . concat
        self.fromColumns cols
    def + that: Table.concat [self, that]

    # Returns a `Table` value contain column matching given name.
    #
    # > import Dataframes.Column 
    # > import Dataframes.Types
    # > import Dataframes.Table 
    # > l1 = [1,2,3,4,5]
    # > l2 = [11,12,13,14,15]
    # > col1 = Column.fromList "col1" Int64Type l1
    # > col2 = Column.fromList "col2" Int64Type l2
    # > table = Table.fromColumns [col1 , col2]
    # > column = table.at "col1"
    #
    # `name`: Label for column.
    # `return`: `Table` value from the `table` for given name.

    def at name:
        self.columns [name]
    
    # Add a single `Column` value to `Table` with given name.
    # 
    # > import Dataframes.Column 
    # > import Dataframes.Types
    # > import Dataframes.Table 
    # > l1 = [1,2,3,4,5]
    # > l2 = [11,12,13,14,15]
    # > col1 = Column.fromList "col1" Int64Type l1
    # > col2 = Column.fromList "col2" Int64Type l2
    # > table = Table.fromColumns [col1 , col2]
    # > l3 = [21,22,23,24,25]
    # > col3 = Column.fromList "col3" Int64Type l3 
    # > newTable = table.setAt "foo" col3
    #
    # `name`: String name for newly added column.
    # `column`: `Column` value to add.
    # `return`: `Table` value containing previous `table` with newly added column.

    def setAt name column:
        cols = self.toList
        before = cols.takeWhile c: (c.name == name) . not
        after = cols.drop (before.length + 1)
        col = column.rename name
        columns = before + [col] + after
        self.fromColumns columns

    # Returns `Column` value from `Table` located under given name.
    #
    # > import Dataframes.Column 
    # > import Dataframes.Types
    # > import Dataframes.Table 
    # > l1 = [1,2,3,4,5]
    # > l2 = [11,12,13,14,15]
    # > col1 = Column.fromList "col1" Int64Type l1
    # > col2 = Column.fromList "col2" Int64Type l2
    # > table = Table.fromColumns [col1 , col2]
    # > col = table.column "col1"
    #
    # `name`: Name of the column to return.
    # `return`: Single `Column` value selected from `self` table by name.
    def column name:
        ix = self.schema.getFieldIndexByName name
        self.columnAt ix    
    
    # Returns `Table` value being a subset of `self` table containing given list of columns.
    #
    # > import Dataframes.Column 
    # > import Dataframes.Types
    # > import Dataframes.Table 
    # > l1 = [1,2,3,4,5]
    # > l2 = [11,12,13,14,15]
    # > col1 = Column.fromList "col1" Int64Type l1
    # > col2 = Column.fromList "col2" Int64Type l2
    # > table = Table.fromColumns [col1 , col2]
    # > newTable = table.columns ["col1"] 
    #
    # `names`: List of column names to be returned.
    # `return`: `Table` value with selected columns from `self` table.

    def columns names:
        columns = names.each self.column
        self.fromColumns columns
    
    # removeColumn :: Int -> Table
    def removeColumn index:
        self.fromWrapper $ self.ptr.removeColumn index

    # remove :: Text -> Table
    def remove name:
        self.removeColumn $ self.schema.getFieldIndexByName name
    def toList:
        self.ptr.toList.each Column.fromColumnWrapper
    def toText:
        self.toList.toText
    def columnNames:
        self.toList.each .name
    def == that:
        self.ptr.equals that.ptr
    def slice beg count:
        cols = self.toList
        slicedCols = cols.each (_.slice beg count)
        self.fromColumns slicedCols
    
    # Returns the first `count` rows
    #
    # > import Dataframes.Column 
    # > import Dataframes.Types
    # > import Dataframes.Table 
    # > l1 = [1,2,3,4,5]
    # > l2 = [11,12,13,14,15]
    # > col1 = Column.fromList "col1" Int64Type l1
    # > col2 = Column.fromList "col2" Int64Type l2
    # > table = Table.fromColumns [col1 , col2]
    # > take2 = table.take 2
    #
    # `count`: Number of rows to take.
    # `return`: `Table` value with first `count` rows from `self` table.

    def take count: self.slice 0 count

    # Drop first `count` rows. 
    #
    # > import Dataframes.Column 
    # > import Dataframes.Types
    # > import Dataframes.Table 
    # > l1 = [1,2,3,4,5]
    # > l2 = [11,12,13,14,15]
    # > col1 = Column.fromList "col1" Int64Type l1
    # > col2 = Column.fromList "col2" Int64Type l2
    # > table = Table.fromColumns [col1 , col2]
    # > take2 = table.drop 2
    #
    # `count`: Number of rows to drop.
    # `return`: `Table` value without first `count` rows from `self` table.

    def drop count:
        leftCount = self.rowCount - count
        self.slice count leftCount
    def toJSON:
        maxCount = 1000 / self.columnCount
        mc = if maxCount < 10 then 10 else maxCount
        rowCount = if self.rowCount < mc then self.rowCount else mc
        cols = self.toList
        columnValueLists = cols.each (_ . slice 0 rowCount . toList)
        JSON.empty . insert "header" self.columnNames . insert "data" columnValueLists
    
    # Returns `Table` value with records for which the given predicate returns `True`.
    #
    # > import Dataframes.Column 
    # > import Dataframes.Types
    # > import Dataframes.Table 
    # > l1 = [1,2,3,4,5]
    # > l2 = [11,12,13,14,15]
    # > col1 = Column.fromList "col1" Int64Type l1
    # > col2 = Column.fromList "col2" Int64Type l2
    # > table = Table.fromColumns [col1 , col2]
    # > filteredTable = table.filter (x: x.at "col2" < 14)
    #
    # `f`: The predicate (Boolean-valued function).
    # `return`: Table with elements satisfying predicate.

    def filter f:
        pred = f TableHandle
        self.fromWrapper $ self.ptr.filter pred
    
    # Returns `Table` value with columns for which the given predicate returns `True`.
    #
    # > import Dataframes.Column 
    # > import Dataframes.Types
    # > import Dataframes.Table 
    # > l1 = [1,2,3,4,5]
    # > l2 = ["a", "b", "c", "d", "e"]
    # > col1 = Column.fromList "col1" Int64Type l1
    # > col2 = Column.fromList "col2" StringType l2
    # > table = Table.fromColumns [col1 , col2]
    # > filteredTable = table.filterColumns .isNumeric
    #
    # `f`: The predicate (Boolean-valued function).
    # `return`: Table with columns satisfying predicate.

    def filterColumns pred:
        cols = self.toList
        filtered = cols.filter pred
        self.fromColumns filtered
    
    # Returns `Table` value with results of applied functions on each of the columns from `self` table.
    #
    # > import Dataframes.Column 
    # > import Dataframes.Types
    # > import Dataframes.Table 
    # > l1 = [1,2,3,4,5]
    # > l2 = [11,12,13,14,15]
    # > col1 = Column.fromList "col1" Int64Type l1
    # > col2 = Column.fromList "col2" StringType l2
    # > table = Table.fromColumns [col1 , col2]
    # > filteredTable = table.eachColumn .max
    #
    # `pred`: {min, max, mean, median, std, var, sum}
    # `return`: Table with function application results.

    def eachColumn pred:
        cols = self.toList
        filtered = cols.each pred
        self.fromColumns filtered

    # Returns `Column` value with results of function `f` application.
    #
    # > import Dataframes.Column 
    # > import Dataframes.Types
    # > import Dataframes.Table 
    # > l1 = [1,2,3,4,5]
    # > l2 = [11,12,13,14,15]
    # > col1 = Column.fromList "col1" Int64Type l1
    # > col2 = Column.fromList "col2" StringType l2
    # > table = Table.fromColumns [col1 , col2]
    # > column = table.each (_.at "col1" * 10)
    #
    # `f`: Function to apply on `self` table.
    # `return`: `Column` value with function application results.

    def each f:
        mapper = f TableHandle
        columnWrapper = self.ptr.eachToColumn "Result" mapper
        Column.fromColumnWrapper columnWrapper
    
    # Adds to `self` table a column with `name` and values as a result of application function `f` on the `self` table.
    #
    # > import Dataframes.Column 
    # > import Dataframes.Types
    # > import Dataframes.Table 
    # > l1 = [1,2,3,4,5]
    # > l2 = [11,12,13,14,15]
    # > col1 = Column.fromList "col1" Int64Type l1
    # > col2 = Column.fromList "col2" StringType l2
    # > table = Table.fromColumns [col1 , col2]
    # > newTable = table.eachTo "col3" (_.at "col1" * 10)
    #
    # `name`: Name of newly created column in result table.
    # `f`: Function to apply on `self` table.
    # `return`: `Table` value with `self` table and additionla column with provided name and values resulting from function `f` application.

    def eachTo name f:
        r = self.each f
        self.setAt name r

    # sortBy :: [(Column, SortOrder, NullPosition)]
    def sortByColumn sortBy:
        self.fromWrapper $ self.ptr.sort (sortBy.each (col, b, c): (col.ptr, b, c))
    # sortBy is list of triples: [(column name :: Text, SortOrder, NullPosition)]
    def sort sortBy:
        sortByColumns = sortBy.each (colName, order, pos): (self.column colName, order, pos)
        self.sortByColumn sortByColumns

    # Remove rows with missing values.
    #
    # > import Dataframes.Table
    # > import Dataframes.IO 
    # > table = CSVParser.readFile "./data/simple_empty.csv"
    # > newTable = table.dropNa
    #
    # `return`: `Table` value without rows containing NA records.

    def dropNa:
        self.fromWrapper $ self.ptr.dropNa

    # Remove rows where missing values occurs for given column.
    #
    # > import Dataframes.Table
    # > import Dataframes.IO 
    # > table = CSVParser.readFile "./data/simple_empty.csv"
    # > newTable = table.dropNaAt "b"
    #
    # `name`: Column name for which we check NA values.
    # `return`: `Table` value without rows containing NA records in given column.

    def dropNaAt columnName:
        self.fromWrapper $ self.ptr.dropNaByName columnName

    # Fill NA/NaN values with `valueToFillWith`.
    #
    # > import Dataframes.Table
    # > import Dataframes.IO 
    # > table = CSVParser.readFile "./data/simple_empty.csv"
    # > newTable = table.fillNa 53
    #
    # `valueToFillWith`: Value to use to fill holes (e.g. 0).
    # `return`: `Table` with holes filled by `valueToFillWith`.

    def fillNa valueToFillWith:
        self.fromWrapper $ self.ptr.fillNa valueToFillWith

    # Fill NA/NaN values with `valueToFillWith` in column `columnName`
    #
    # > import Dataframes.Table
    # > import Dataframes.IO 
    # > table = CSVParser.readFile "./data/simple_empty.csv"
    # > newTable = table.fillNaAt "b" 53
    #
    # `columnName`: Name of the column to fill holes in.
    # `valueToFillWith`: Value to use to fill holes (e.g. 0).
    # `return`: `Table` with holes in column `columnName` filled with `valueToFillWith `.

    def fillNaAt columnName valueToFillWith:
        self.fromWrapper $ self.ptr.fillNaAt columnName valueToFillWith

    def interpolate:
        self.fromWrapper $ self.ptr.interpolate
    def toColumn:
        case self.toList of
            [c]: c
            t: throw $ "Table.toColumn: table must have exactly 1 column, but has " + t.length.toText

    # Generates `Table` with number and ratio of NA/NaN values for each column.
    #
    # > import Dataframes.Table
    # > import Dataframes.IO 
    # > table = CSVParser.readFile "./data/simple_empty.csv"
    # > newTable = table.describeNa
    #
    # `return`: `Table` value with statistics of NA/NaN values for each column.

    def describeNa:
        cols = self.toList
        nrows = self.rowCount
        names = cols . each .name
        nullCounts = cols . each .nullCount
        nullRatios = nullCounts . each (_.toReal / nrows.toReal)
        namesCol      = Column.fromList "colname" StringType names
        nullCountsCol = Column.fromList "count"   Int64Type  nullCounts
        nullRatiosCol = Column.fromList "ratio"   DoubleType nullRatios
        self.fromColumns [namesCol, nullCountsCol, nullRatiosCol]

    def shortRep:
        "Table<" + self.columnCount.toText + "×" + self.rowCount.toText + ">"

    # Compute pairwise Pearson's correlation of columns, excluding NA/null values.
    #
    # > import Dataframes.Column 
    # > import Dataframes.Types
    # > import Dataframes.Table 
    # > l1 = [1,2,3,4,5]
    # > l2 = [11,12,13,14,15]
    # > col1 = Column.fromList "col1" Int64Type l1
    # > col2 = Column.fromList "col2" StringType l2
    # > table = Table.fromColumns [col1 , col2]
    # > correlations = table.corr
    #
    # `return`: `Table` value with pairwise correlations calculated for `self` table.

    def corr:
        self.fromWrapper $ self.ptr.corr

    # Compute pairwise Pearson's correlations with given column, excluding NA/null values.
    #
    # > import Dataframes.Column 
    # > import Dataframes.Types
    # > import Dataframes.Table 
    # > l1 = [1,2,3,4,5]
    # > l2 = [11,12,13,14,15]
    # > col1 = Column.fromList "col1" Int64Type l1
    # > col2 = Column.fromList "col2" StringType l2
    # > table = Table.fromColumns [col1 , col2]
    # > correlations = table.corrWith "col2"
    #
    # `columnName`: Column for which the correlations are calculated.
    # `return`: `Table` value including correlations with `columnName` column calculated for `self` table.

    def corrWith columnName:
        column = self.at columnName . toColumn
        corrCol = Column.fromColumnWrapper $ self.ptr.corrWith column.ptr
        colNames = self.toList . each .name
        corrList = corrCol.toList
        l1 = colNames . zip corrList
        sorted = l1.sortBy .second
        names = sorted.each .first
        vals  = sorted.each .second
        col1 = Column.fromList "column" StringType names
        col2 = Column.fromList ("CORR_WITH_" + columnName) DoubleType vals
        Table.fromColumns [col1, col2]

    # Generates descriptive statistics that summarize the central tendency, dispersion and shape of the values in given column distribution. 
    #
    # Analyzes just numeric values, excluding NA/null values. Returns statistics like: mean, standard deviation, minimum, 1st quantile, median, 3rd quantile, maximum.
    #
    # > import Dataframes.Column 
    # > import Dataframes.Types
    # > import Dataframes.Table 
    # > l1 = [1,2,3,4,5]
    # > l2 = [11,12,13,14,15]
    # > col1 = Column.fromList "col1" Int64Type l1
    # > col2 = Column.fromList "col2" StringType l2
    # > table = Table.fromColumns [col1 , col2]
    # > correlations = table.describeColumn "col2"
    #
    # `columnName`: String value, name of the column to calculate statistics for.
    # `return`: `Table` value with statistics for given column.

    def describeColumn columnName:
        col = self.at columnName . toColumn
        min = col.min
        max = col.max
        mean = col.mean
        std = col.std
        quart1 = col.quantile 0.25
        median = col.median
        quart3 = col.quantile 0.75
        Table.fromColumns [mean, std, min, quart1, median, quart3, max]

    def countValues columnName:
        self.at columnName . toColumn . countValues

    # aggregateBy :: Text -> [(Text, [AggregateFunction])] -> Table
    def aggregateBy keyColumnName aggregations:
        keyColumnWrapper = self.column keyColumnName . ptr
        aggregationWithWrappers = aggregations.each (colname, aggrs): (self.column colname . ptr, aggrs.each .toInt)
        self.fromWrapper $ self.ptr.aggregateBy keyColumnWrapper aggregationWithWrappers

    # Describe returns informations about whole table like standard deviation, minium, maximum, mean, median qunatile 0.25 and 0.75 for each column.
    #
    # > import Dataframes.Column 
    # > import Dataframes.Types
    # > import Dataframes.Table 
    # > l1 = [1,2,3,4,5]
    # > l2 = [11,12,13,14,15]
    # > col1 = Column.fromList "col1" Int64Type l1
    # > col2 = Column.fromList "col2" StringType l2
    # > table = Table.fromColumns [col1 , col2]
    # > correlations = table.describe
    #
    # `return`: `Table` value with statistics for `self` table.

    def describe:
        numerics = self.filterColumns .isNumeric
        names = numerics.columnNames 

        std = names.each (name: self.column name . std )
        stdVal = std.map .toList 
        stdFlatList = stdVal.concat

        min = names.each (name: self.column name . min )
        minVal = min.map .toList 
        minFlatList = minVal.concat

        max = names.each (name: self.column name . max )
        maxVal = max.map .toList 
        maxFlatList = maxVal.concat

        mean = names.each (name: self.column name . mean )
        meanVal = mean.map .toList 
        meanFlatList = meanVal.concat

        quart1 = names.each (name: self.column name . quantile 0.25 )
        quart1Val = quart1.map .toList 
        quart1FlatList = quart1Val.concat

        median = names.each (name: self.column name . median )
        medianVal = median.map .toList 
        medianFlatList = medianVal.concat

        quart3 = names.each (name: self.column name . quantile 0.75 )
        quart3Val = quart3.map .toList 
        quart3FlatList = quart3Val.concat

        col1 = Column.fromList "column" StringType names 
        col2 = Column.fromList "Mean" DoubleType meanFlatList 
        col3 = Column.fromList "Std dev" DoubleType stdFlatList 
        col4 = Column.fromList "Min" DoubleType minFlatList 
        col5 = Column.fromList "Quantile 0.25" DoubleType quart1FlatList 
        col6 = Column.fromList "Median" DoubleType medianFlatList 
        col7 = Column.fromList "Quantile 0.75" DoubleType quart3FlatList 
        col8 = Column.fromList "Max" DoubleType maxFlatList 
        Table.fromColumns [col1, col2, col3, col4, col5, col6, col7, col8]

    def chart: ChartBuilder self

class ChartBuilder:
    table :: Table

    # Plot y versus x as markers or lines.
    #
    # > import Dataframes.Column 
    # > import Dataframes.Types
    # > import Dataframes.Table 
    # > l1 = [1,2,3,4,5]
    # > l2 = [11,12,13,14,15]
    # > col1 = Column.fromList "col1" Int64Type l1
    # > col2 = Column.fromList "col2" StringType l2
    # > table = Table.fromColumns [col1 , col2]
    # > plot1 = table.chart.plot "col1" "col2"
    #
    # `columnName1`: X column name.
    # `columnName2`: Y column name.
    # `return`: [] OBRAZEK

    def plot columnName1 columnName2:
        c1 = self.table.at columnName1 . toColumn
        c2 = self.table.at columnName2 . toColumn
        Plot c1 c2 "o" Nothing

    def plotDate columnName1 columnName2: 
        c1 = self.table.at columnName1 . toColumn
        c2 = self.table.at columnName2 . toColumn
        PlotDate c1 c2

    def scatter columnName1 columnName2: 
        c1 = self.table.at columnName1 . toColumn
        c2 = self.table.at columnName2 . toColumn
        Scatter c1 c2

    # Plot a histogram.
    #
    # Compute and plot histogram of x.
    #
    # > import Dataframes.Column 
    # > import Dataframes.Types
    # > import Dataframes.Table 
    # > l1 = [1,2,3,4,5]
    # > l2 = [11,12,13,14,15]
    # > col1 = Column.fromList "col1" Int64Type l1
    # > col2 = Column.fromList "col2" StringType l2
    # > table = Table.fromColumns [col1 , col2]
    # > plot1 = table.chart.histogram "col1"
    #
    # `columnName`: X column name.
    # `return`: [] OBRAZEK

    def histogram columnName:
        c = self.table.at columnName . toColumn
        Histogram c 10 Map.empty

    # Fit and plot a bivariate kernel density estimate.
    #
    # > import Dataframes.Column 
    # > import Dataframes.Types
    # > import Dataframes.Table 
    # > l1 = [1,2,3,4,5]
    # > l2 = [11,12,13,14,15]
    # > col1 = Column.fromList "col1" Int64Type l1
    # > col2 = Column.fromList "col2" StringType l2
    # > table = Table.fromColumns [col1 , col2]
    # > plot1 = table.chart.kde2 "col1" "col2"
    #
    # `columnName1`: First input data.
    # `columnName2`: Second input data.
    # `return`: [] OBRAZEK

    def kde2 columnName1 columnName2:
        c1 = self.table.at columnName1 . toColumn
        c2 = self.table.at columnName2 . toColumn
        KDE2 c1 c2 "Blues_r"

    # Fit and plot a univariate kernel density estimate.
    #
    # > import Dataframes.Column 
    # > import Dataframes.Types
    # > import Dataframes.Table 
    # > l1 = [1,2,3,4,5]
    # > l2 = [11,12,13,14,15]
    # > col1 = Column.fromList "col1" Int64Type l1
    # > col2 = Column.fromList "col2" StringType l2
    # > table = Table.fromColumns [col1 , col2]
    # > plot1 = table.chart.kde "col1"
    #
    # `columnName`: Input data.
    # `return`: [] OBRAZEK

    def kde columnName:
        c = self.table.at columnName . dropNa . toColumn
        KDE c Nothing

    # Plot rectangular data as a color-encoded matrix.
    #
    # > import Dataframes.Column 
    # > import Dataframes.Types
    # > import Dataframes.Table 
    # > l1 = [1,2,3,4,5]
    # > l2 = [11,12,13,14,15]
    # > col1 = Column.fromList "col1" Int64Type l1
    # > col2 = Column.fromList "col2" StringType l2
    # > table = Table.fromColumns [col1 , col2]
    # > correlations = table.corr 
    # > heatmapPlot = correlations.chart.heatmap 
    #
    # `return`: [] OBRAZEK

    def heatmap:
        Heatmap self.table "RdBu_r" Nothing

class Heatmap:
    data :: Table
    colorMap :: Text
    annotations :: Maybe Text

    def render:
        Matplotlib.heatmap self.data.ptr.ptr self.colorMap self.annotations

    def toChart: Chart self.render

    def + that:
        self.toChart.+ that

    def toJSON: self.toChart.toJSON

    def setColorMap s: Heatmap self.data s self.annotations
    def setAnnotations s: Heatmap self.data self.colorMap (Just s)
